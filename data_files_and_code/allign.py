import rdflib


def auto_alignment(source_onto_path, mappings_path, updated_onto_path ):

  '''

  Integrates validated ontology mappings with the source ontology.

  Input Parameters:
    source_onto_path (str): Local file path to the source ontology.
    mappings_path (str): Path to the output RDF file generated by AML containing the validated mappings.
    updated_onto_path (str): Path where the updated ontology will be saved.

    Output:
        Updates the source ontology with the alignments from the mappings file and saves it to the specified path.
        This updated ontology will be stored at the location specified in the updated_onto_path parameter.

  '''

  ALIGNMENT = rdflib.Namespace("http://knowledgeweb.semanticweb.org/heterogeneity/")

  #  Graph for the ontology
  ontology_graph = rdflib.Graph()
  ontology_graph.parse(source_onto_path, format="application/rdf+xml" )

  # Parse the RDF/XML alignment file
  mapping_graph = rdflib.Graph()
  mapping_graph.parse(mappings_path,  format="application/rdf+xml" )

  sorted_triples = sorted(mapping_graph, key=lambda x: (str(x[0]), str(x[1])))   # Sort triples

  bnode_data = {}  # Dictionary to store information about each BNode

  # Iterate through sorted triples
  for subj, pred, obj in sorted_triples:
      if isinstance(subj, rdflib.BNode):
          bnode_data.setdefault(subj, []).append((pred, obj))
      elif isinstance(obj, rdflib.BNode):
          bnode_data.setdefault(obj, []).append((pred, subj))

  # Process each BNode for equivalence
  for bnode, properties in bnode_data.items():
    entity1 = None
    entity2 = None
    measure = None
    relation = None

    for pred, obj in properties:
      if pred == ALIGNMENT.alignmententity1:
        entity1 = obj
      elif pred == ALIGNMENT.alignmententity2:
        entity2 = obj
      elif pred == ALIGNMENT.alignmentmeasure:
        measure = float(obj)
      elif pred == ALIGNMENT.alignmentrelation:
        relation = str(obj)

    if relation == '=' and measure and measure >= 0.5:
      print(entity1, entity2)
      is_object_property = (entity1, rdflib.RDF.type, rdflib.OWL.ObjectProperty) in ontology_graph
      is_datatype_property = (entity1, rdflib.RDF.type, rdflib.OWL.DatatypeProperty) in ontology_graph
      is_property = is_object_property or is_datatype_property
      if is_property:
        ontology_graph.add((entity1, rdflib.OWL.equivalentProperty, entity2))
      else:
        ontology_graph.add((entity1, rdflib.OWL.equivalentClass, entity2))

  # Save the updated ontology
  ontology_graph.serialize(destination = updated_onto_path, format="pretty-xml")
  print("Updated museitchassets ontology with equivalence classes and properties based on the mappings.")


# Execution
museit_path = 'museITchassets.rdf'
mappings_path = 'mappings_museITchassets_schema.rdf'
updated_onto_path = "updated_museITchassets.rdf"

auto_alignment(museit_path, mappings_path, updated_onto_path)